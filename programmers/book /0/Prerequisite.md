# 1

1. 타인의 풀이를 보고 사고를 넓혀라
   - 한문제의 다양한 접근방식을 보고 여러 코딩 스킬을 배울수있다
2. 나만의 테스트 케이스를 추가하여 실행 시켜봐라
   - 나만의 테스트 코드를 작성하게 되면 자주 사용함에따라 상황별 예외 케이스를 추가할수있다

# 2

1. 기록하기
   - 실제로 현재 못푼문제들이 있는데 그럴땐 풀이 과정이나 생각해둔 해결법을 기록해라
   - 기록하면 시간이 지난후 비교해보고 복기가 되고 발전이늘어난다
2. 시험 보듯이해라
   - 정해진 시간안에 시간 배분을 해보는 행동으로 긴장감을 낮춰라
   - 효율성을 높여라
3. 오랜시간을 투자해라
   - 개인적인 사견 ) 일단 4주안에 책은끝낼려고 해보자 100문제
4. 자신만의 언어로 요약하자
   - 코드를 작성하기전에 미리 한글로 작동 방식을 적는 연습을 하자

# 3

## 문제 분석 연습방법

0. 충분히 고민하는 시간을 가지기
   - 아직 문제가 쉬운것부터 들어갈예정임으로 총 4문제를 2시간 푼다고 생가가했을때 20분이상 충분히 고민하기
1. 문제를 쪼개서 분석하기
   - 전체적인 흐름을 전부 볼려고 하지말고 갈수록 한번에 해결하기 어렵기때문에 분해해서 천천히 나아가기
2. 제약 사항을 파악하고 테스트 케이스를 추가하기
   - 제약 사항을 부분 부분 나누지말고 처음부터 구분해야 알고리즘 사용할때 편리하다
3. 입력 값을 분석하기
   - 프로그래머스에서는 쉽게 구별되있지만 실제 코딩 테스트에서는 알고리즘별 입력값마다 사용해야되는것이 다르기때문에 중요
4. 핵심키워드
   - 키워드를 구분해야 여러 사용가능한 알고리즘중에서 핵심을 선택하고 구별할수있다
5. 데이터흐름이나 구성을 파악하기
   - 윗부분을 나눠서 생각하는 걸로 좋은 알고리즘과 구현방향을 생가가할때 중요한 고려 대상

## 핵심 키워드 표

<table>
  <tr>
    <th></th>
    <th>키워드</th>
    <th>상황</th>
  </tr>
  <tr>
    <td rowspan="4" >스택</td>
    <td > 쌍이 맞는지</td>
    <td>무언가 저장하고 반대로 처리해야 할때</td>
  </tr>
  <tr>
    <td>최근</td>
    <td> 데이터 의 조합이 균형을 이뤄야 할때</td>
  </tr>
  <tr>
    <td></td>
    <td>알고리즘이 재귀 특성을 가질때 </td>
  </tr>
  <tr>
    <td></td>
    <td>최근 상태 추적</td>
  </tr>
   <tr>
    <td rowspan="2" >큐</td>
    <td >순서대로 ,  ~대로 동작하는 경우</td>
    <td>특정 조건에 따라 시뮬레이션 할때 </td>
  </tr>
  <tr>
    <td>스케줄링 , 최소 시간</td>
    <td> 시작 지점부터 목표 지점까지 최단거리 </td>
  </tr>
  <tr>
    <td rowspan="2">깊이 우선 탐색</td>
    <td>모든 경로</td>
    <td>메모리 사용량이 제한적일 때의 탐색</td>
  </tr>
  <tr>
    <td></td>
    <td>백트래킹 문제를 풀 때</td>
  </tr>
  <tr>
    <td rowspan="2">너비 우선 탐색</td>
    <td>최적  , 레벨 순회</td>
    <td>시작 지점부터 최단 경로나 최소 횟수를 찾아야 할 때 </td>
  </tr>
  <tr>
    <td>최소 단계  , 네트워크 전파</td>
    <td></td>
  </tr>
  <tr>
    <td rowspan="2">백트래킹</td>
    <td>조합, 순열</td>
    <td>조합 및 순열 문제</td>
  </tr>
  <tr>
    <td>부분 집합</td>
    <td>특정 조건을 만족하는 부분 집합</td>
  </tr>
  <tr>
    <td rowspan="3">최단 경로</td>
    <td>최단 경로 , 최소 시간</td>
    <td>다익스트라 : 특정 지점에서 나머지 지점까지 가는 최단 경로</td>
  </tr>
  <tr>
    <td>최소 비용 , 트래픽</td>
    <td>벨만-포드 : 음의순환 탐지 , 음의 가중치를 가진 그래프에서 최단경로</td>
  </tr>
  <tr>
    <td>음의 순환 , 단일 출발점 경로 </td>
    <td></td>
  </tr>
</table>

# 4. 의사코드

- 추상적인 단계에서 여러가지 방식을 고려하는법을 학습

1. 세부 구현이 아닌 동작 중심으로
   - 세부구현이 먼저가 되는순간 의사코드의 장점이 날라가게 된다 (자유롭게 작성하기 어렵다 )
2. 문제 해결 순서로
   - 실제 구현할 코드의 주석이 되도 한다
3. 충분한 테스트

# 5. 시간 복잡도 정리

코딩테스트에서 중요한 개념 중 하나가 **시간 복잡도(Time Complexity)**입니다. 시간 복잡도는 알고리즘이 실행되는 데 걸리는 시간을 입력 크기(n)에 따라 분석하는 개념입니다.

---

## 1. 빅오 표기법(Big-O Notation)

시간 복잡도를 표현할 때 가장 많이 사용하는 표기법으로, **최악의 경우**를 기준으로 알고리즘의 실행 시간을 나타냅니다.

### 자주 등장하는 빅오 표기법

| 빅오 표기법 | 의미           | 예제                                            |
| ----------- | -------------- | ----------------------------------------------- |
| O(1)        | 상수 시간      | 배열에서 인덱스로 특정 원소 접근                |
| O(log n)    | 로그 시간      | 이진 탐색(Binary Search)                        |
| O(n)        | 선형 시간      | 배열 전체 순회 (for문 1개)                      |
| O(n log n)  | 로그 선형 시간 | 병합 정렬(Merge Sort), 퀵 정렬(Quick Sort) 평균 |
| O(n²)       | 이차 시간      | 중첩 루프(이중 for문)                           |
| O(2ⁿ)       | 지수 시간      | 피보나치 수열(재귀적 구현)                      |
| O(n!)       | 팩토리얼 시간  | 모든 경우의 수 탐색(브루트포스)                 |

---

## 2. 시간 복잡도 분석 방법

### (1) 반복문 분석

- **단일 반복문** → O(n)
- **중첩 반복문** → O(n²)
- **반으로 줄어드는 반복문** → O(log n)

```js
// O(n) - 배열을 한 번 순회
for (let i = 0; i < n; i++) {
  console.log(i);
}

// O(n²) - 중첩 반복문 (이중 for문)
for (let i = 0; i < n; i++) {
  for (let j = 0; j < n; j++) {
    console.log(i, j);
  }
}

// O(log n) - i가 2배씩 증가 → 로그 시간
for (let i = 1; i < n; i *= 2) {
  console.log(i);
}
```

---

## 3. 자료구조에 따른 시간 복잡도

### (1) 배열 (Array)

| 연산                 | 시간 복잡도 |
| -------------------- | ----------- |
| 접근 (indexing)      | O(1)        |
| 삽입 (끝에 추가)     | O(1)        |
| 삽입 (중간에 추가)   | O(n)        |
| 삭제 (끝에서 제거)   | O(1)        |
| 삭제 (중간에서 제거) | O(n)        |

### (2) 해시 테이블 (Hash Table)

| 연산 | 평균 시간 복잡도 | 최악 시간 복잡도 (충돌 발생 시) |
| ---- | ---------------- | ------------------------------- |
| 삽입 | O(1)             | O(n)                            |
| 삭제 | O(1)             | O(n)                            |
| 탐색 | O(1)             | O(n)                            |

### (3) 이진 탐색 트리 (Binary Search Tree, BST)

| 연산 | 평균 시간 복잡도 | 최악 시간 복잡도 (편향 트리) |
| ---- | ---------------- | ---------------------------- |
| 삽입 | O(log n)         | O(n)                         |
| 삭제 | O(log n)         | O(n)                         |
| 탐색 | O(log n)         | O(n)                         |

---

## 4. 알고리즘 예시 및 시간 복잡도

| 알고리즘                 | 시간 복잡도       |
| ------------------------ | ----------------- |
| 선형 탐색(Linear Search) | O(n)              |
| 이진 탐색(Binary Search) | O(log n)          |
| 버블 정렬(Bubble Sort)   | O(n²)             |
| 퀵 정렬(Quick Sort)      | O(n log n) (평균) |
| 병합 정렬(Merge Sort)    | O(n log n)        |
| 힙 정렬(Heap Sort)       | O(n log n)        |

---

## 5. 코딩 테스트에서 시간 제한과 시간 복잡도

프로그래머스나 백준 같은 코딩 테스트에서는 **1초당 약 10⁷~10⁸번의 연산**을 처리할 수 있습니다.

### 입력 크기에 따른 적절한 알고리즘 선택

| 입력 크기 (n) | 선택 가능한 시간 복잡도 |
| ------------- | ----------------------- |
| n ≤ 10⁷       | O(n) 또는 O(n log n)    |
| n ≤ 10⁵       | O(n log n)              |
| n ≤ 10³       | O(n²)                   |
| n ≤ 20        | O(2ⁿ)                   |
| n ≤ 10        | O(n!)                   |

---

## 6. 최적화 전략

### (1) 반복문 줄이기

- O(n²) → O(n log n) 또는 O(n)으로 개선
- 불필요한 중복 루프 제거
- 해시 테이블 활용하여 탐색 최적화

### (2) 정렬 활용

- 문제를 해결하기 전에 **정렬(O(n log n))**을 수행하면 이후 연산을 O(log n)으로 줄일 수 있음

### (3) 메모이제이션(Memoization)

- 피보나치 수열을 예로 들면, 기존 O(2ⁿ)의 재귀를 O(n)으로 최적화 가능

```js
// O(n²) - 중복 계산 존재
function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
}

// O(n) - 메모이제이션 적용
function fibMemo(n, memo = {}) {
  if (n in memo) return memo[n];
  if (n <= 1) return n;
  return (memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo));
}
```

---

## 7. 마무리

- **시간 복잡도 분석은 코딩 테스트에서 필수**
- **입력 크기에 따라 적절한 알고리즘 선택**
- **O(n²) 이상의 알고리즘을 최대한 피하고 O(n log n) 이하로 최적화**
- **해시 테이블, 정렬, 메모이제이션 등 다양한 최적화 기법 활용**

➡️ **시간 복잡도 최적화는 결국 더 빠르고 효율적인 코드를 만드는 핵심 요소입니다.**
